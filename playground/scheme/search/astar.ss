#lang scheme

(require (prefix-in prio: "priority-queue.ss"))
(provide a*)

(define-struct item (prio depth state path))

(define (a* start goal? heuristic generate-moves! success!)
  (let ((depth-hash (make-hash))
        (frontier   (prio:make (lambda (a b)
                                 (< (item-prio a) (item-prio b))))))
    (define (add! depth state path)
      (let ((prev-depth (hash-ref depth-hash state #f)))
        (when (or (not prev-depth)
                  (< depth prev-depth))
          (hash-set! depth-hash state depth)
          (prio:insert! frontier (make-item (+ depth (heuristic state))
                                            depth state path)))))
    (define (try-next!)
      (let* ((item  (prio:extract-min! frontier))
             (depth (item-depth item))
             (state (item-state item))
             (path  (item-path item)))
;        (when (= depth (hash-ref depth-hash state))
        (when (goal? state)
          (success! path))
        (generate-moves! state
                         (lambda (cost desc next-state)
                           (add! (+ depth cost)
                                 next-state
                                 (cons desc path))))))
    (add! 0 start '())
    (let loop ()
      (unless (prio:empty? frontier)
        (try-next!)
        (loop)))))